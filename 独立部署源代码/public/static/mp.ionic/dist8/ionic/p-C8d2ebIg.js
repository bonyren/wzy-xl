/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
import{d as t}from"./p-ZjP4CjeZ.js";import{MENU_BACK_BUTTON_PRIORITY as e}from"./p-CvaZMP6T.js";import{f as n}from"./p-4DxY6_gG.js";import{c as r}from"./p-C-Cct-6D.js";import{b as s}from"./p-Br3vSlYh.js";import{c as a}from"./p-C87oPMMF.js";const o=t=>a().duration(t?400:300),i=t=>{let e,n;const r=t.width+8,i=a(),u=a();t.isEndSide?(e=r+"px",n="0px"):(e=-r+"px",n="0px"),i.addElement(t.menuInnerEl).fromTo("transform",`translateX(${e})`,`translateX(${n})`);const c="ios"===s(t),p=c?.2:.25;return u.addElement(t.backdropEl).fromTo("opacity",.01,p),o(c).addAnimation([i,u])},u=t=>{let e,n;const r=s(t),i=t.width;t.isEndSide?(e=-i+"px",n=i+"px"):(e=i+"px",n=-i+"px");const u=a().addElement(t.menuInnerEl).fromTo("transform",`translateX(${n})`,"translateX(0px)"),c=a().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${e})`),p=a().addElement(t.backdropEl).fromTo("opacity",.01,.32);return o("ios"===r).addAnimation([u,c,p])},c=t=>{const e=s(t),n=t.width*(t.isEndSide?-1:1)+"px",r=a().addElement(t.contentEl).fromTo("transform","translateX(0px)",`translateX(${n})`);return o("ios"===e).addAnimation(r)},p=(()=>{const s=new Map,a=[],o=async(t,e=!1)=>{if(await d(),"start"===t||"end"===t){const r=a.filter((e=>e.side===t&&!e.disabled));if(r.length>=1)return r.length>1&&e&&n(`menuController queried for a menu on the "${t}" side, but ${r.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,r.map((t=>t.el))),r[0].el;const s=a.filter((e=>e.side===t));if(s.length>=1)return s.length>1&&e&&n(`menuController queried for a menu on the "${t}" side, but ${s.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,s.map((t=>t.el))),s[0].el}else if(null!=t)return w((e=>e.menuId===t));return w((t=>!t.disabled))||(a.length>0?a[0].el:void 0)},p=async()=>(await d(),f()),m=(t,e)=>{s.set(t,e)},f=()=>w((t=>t._isOpen)),l=()=>a.some((t=>t.isAnimating)),w=t=>{const e=a.find(t);if(void 0!==e)return e.el},d=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((t=>new Promise((e=>r(t,e))))));return m("reveal",c),m("push",u),m("overlay",i),null==t||t.addEventListener("ionBackButton",(t=>{const n=f();n&&t.detail.register(e,(()=>n.close()))})),{registerAnimation:m,get:o,getMenus:async()=>(await d(),a.map((t=>t.el))),getOpen:p,isEnabled:async t=>{const e=await o(t);return!!e&&!e.disabled},swipeGesture:async(t,e)=>{const n=await o(e);return n&&(n.swipeGesture=t),n},isAnimating:async()=>(await d(),l()),isOpen:async t=>{if(null!=t){const e=await o(t);return void 0!==e&&e.isOpen()}return void 0!==await p()},enable:async(t,e)=>{const n=await o(e);return n&&(n.disabled=!t),n},toggle:async t=>{const e=await o(t,!0);return!!e&&e.toggle()},close:async t=>{const e=await(void 0!==t?o(t,!0):p());return void 0!==e&&e.close()},open:async t=>{const e=await o(t,!0);return!!e&&e.open()},_getOpenSync:f,_createAnimation:(t,e)=>{const n=s.get(t);if(!n)throw new Error("animation not registered");return n(e)},_register:t=>{a.indexOf(t)<0&&a.push(t)},_unregister:t=>{const e=a.indexOf(t);e>-1&&a.splice(e,1)},_setOpen:async(t,e,n,r)=>{if(l())return!1;if(e){const e=await p();e&&t.el!==e&&await e.setOpen(!1,!1)}return t._setOpen(e,n,r)}}})();export{p as m}